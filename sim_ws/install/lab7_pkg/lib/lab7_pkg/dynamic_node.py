#!/usr/bin/env python3

# ==================================================================================================
# Standard Imports
# ==================================================================================================

import csv
import numpy as np
import math
import atexit
import os

# ==================================================================================================
# ROS Imports
# ==================================================================================================

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import PoseStamped, Pose, Quaternion, Point
from nav_msgs.msg import Odometry, OccupancyGrid
from ackermann_msgs.msg import AckermannDriveStamped
from visualization_msgs.msg import Marker, MarkerArray
from tf_transformations import euler_from_quaternion

# ==================================================================================================
# Utility Imports
# ==================================================================================================

import lab7_pkg.helper as hp
import lab7_pkg.variables as vars

# ==================================================================================================
# Miscellaneous Imports
# ==================================================================================================

from typing import *

# ==================================================================================================
# Vec2 Class
# ==================================================================================================

class Vec2:
    def __init__(
        self,
        x : int = 0,
        y : int = 0
    ):
        self.x = int(x)
        self.y = int(y)

    # Generated by ChatGPT for use as a key in a dictionary
    def __eq__(self, other):
        if isinstance(other, Vec2):
            return self.x == other.x and self.y == other.y
        return False

    def __hash__(self):
        return hash((self.x, self.y))

class Vec2f:
    def __init__(
        self,
        x : float = 0.0,
        y : float = 0.0
    ):
        self.x = float(x)
        self.y = float(y)

# ==================================================================================================
# Vertex Class
# ==================================================================================================

class Vertex:
    def __init__(
        self,
        position : Vec2 = Vec2(),
        parent = None,
        input_dir : float = 0.0,
        cost : float = 0.0
    ):
        self.position = position
        self.parent = parent
        self.input_dir = input_dir
        self.cost = cost

# ==================================================================================================
# Dynamic Node Class
# ==================================================================================================

class Dynamic(Node):
    def __init__(self):
        super().__init__('dynamic_node')
        
        # ==========================================================================================
        # Subscriber / Publisher Topics
        # ==========================================================================================
        
        # Car
        scan_topic  = '/scan'
        pose_topic  = '/pf/viz/inferred_pos'
        odom_topic  = '/ego_racecar/odom'
        drive_topic = '/drive'
        
        # Map
        global_occ_topic = '/global_occupancy'
        local_occ_topic  = '/local_occupancy'
        
        # Pathing
        sample_grid_topic = '/sample_grid'
        path_topic        = '/path_view'
        goals_topic       = '/goal_view'
        
        # ==========================================================================================
        # Subscribers / Publishers
        # ==========================================================================================
        
        # Car
        self.scan_sub  = self.create_subscription(LaserScan, scan_topic, self.scan_callback, 10)
        self.pose_sub  = self.create_subscription(PoseStamped, pose_topic, self.pose_callback, 10)
        self.odom_sub  = self.create_subscription(Odometry, odom_topic, self.odom_callback, 10)
        self.drive_pub = self.create_publisher(AckermannDriveStamped, drive_topic, 10)
        
        # Map
        self.global_occ_pub = self.create_publisher(MarkerArray, global_occ_topic, 10)
        self.local_occ_pub  = self.create_publisher(MarkerArray, local_occ_topic, 10)
        
        # Pathing
        self.sample_grid_pub = self.create_publisher(MarkerArray, sample_grid_topic, 10)
        self.path_pub        = self.create_publisher(MarkerArray, path_topic, 10)
        self.goals_pub       = self.create_publisher(MarkerArray, goals_topic, 10)
        
        # ==========================================================================================
        # Runtime Variables
        # ==========================================================================================
        
        # Car
        self.position : Vec2f = None  # Physical position of car on map
        self.cell_pos : Vec2  = None  # Cell position of car on map
        self.rotation : float = None  # Rotation relative to map frame (radians)
        
        # Map
        self.global_occ_grid : Dict[Vec2, float] = {}  # Static global occupancy grid
        self.local_occ_grid  : Dict[Vec2, float] = {}  # Dynamic local occupancy grid
        
        # Pathing
        self.curr_goal : Vec2 = Vec2()  # Cell position for current goal
        
        # ==========================================================================================
        # Runtime Constants
        # ==========================================================================================
        
        # Occupancy Grid
        self.cell_size   : float = 0.05
        self.local_width : int   = 20
        self.local_depth : int   = 40
        self.bubble_offs : List[Vec2] = [
            Vec2( 0,  0), Vec2( 0, -1), Vec2( 1,  0), Vec2(-1,  0), Vec2( 0,  1), Vec2( 1,  1),
            Vec2( 1, -1), Vec2(-1,  1), Vec2(-1, -1), Vec2( 0, -2), Vec2( 2,  0), Vec2(-2,  0),
            Vec2( 0,  2), Vec2( 2, -1), Vec2(-1,  2), Vec2(-1, -2), Vec2(-2,  1), Vec2(-2, -1),
            Vec2( 1, -2), Vec2( 1,  2), Vec2( 2,  1), Vec2( 2, -2), Vec2( 2,  2), Vec2(-2,  2),
            Vec2(-2, -2), Vec2( 0, -3), Vec2( 0,  3), Vec2( 3,  0), Vec2(-3,  0), Vec2(-1,  3),
            Vec2(-1, -3), Vec2( 3, -1), Vec2( 1, -3), Vec2( 3,  1), Vec2(-3,  1), Vec2( 1,  3),
            Vec2(-3, -1), Vec2( 3, -2), Vec2( 2,  3), Vec2(-3, -2), Vec2( 3,  2), Vec2( 2, -3),
            Vec2(-2,  3), Vec2(-2, -3), Vec2(-3,  2), Vec2( 0,  4), Vec2( 0, -4), Vec2(-4,  0),
            Vec2( 4,  0)
        ]
        
        # Environment Information
        self.root_dir : str = self.get_root_dir()  # Parent directory to package folders
        
        # File Information
        self.global_occ_filename : str = self.get_global_occ_filename()  # Global occupancy filename
        self.goals_filename      : str = self.get_goals_filename()       # Local occupancy filename
        
        # Status
        self.mapping : bool = self.get_state()  # Whether the program is in mapping or driving mode
        
        # Pathing
        self.goal_list : List[Vec2] = self.read_goals()  # Ordered list of goal cells around the map
    
    # ==============================================================================================
    # Setup / Teardown Functions
    # ==============================================================================================
    
    def get_root_dir(self) -> str:
        """
        Query user for full path of parent folder to package folders
        
        Returns:
            Path string for root directory
        """
        
        while True:
            # path : str = input("Enter package root directory: ")
            path : str = '/home/vy/GalacticRacing/sim_ws/src'
            
            if os.path.exists(path):
                return path
            else:
                print("Invalid path. Try again.")
    
    def get_global_occ_filename(self) -> str:
        """
        Query user for global occupancy grid filename
        
        Returns:
            Full path to global occupancy grid file
        """
        
        while True:
            # filename : str = input("Enter global occupancy filename: ")
            filename : str = 'AEB_flexito.csv'
            
            if os.path.exists(self.root_dir + '/lab7_pkg/occ_grids/' + filename):
                return self.root_dir + '/lab7_pkg/occ_grids/' + filename
            else:
                print("File does not exist. Try again.")
    
    def get_goals_filename(self) -> str:
        """
        Query user for goal markers filename
        
        Returns:
            Full path to goal markers file
        """
        
        while True:
            # filename : str = input("Enter goal marker filename: ")
            filename : str = 'AEB_flexito.csv'
            
            if os.path.exists(self.root_dir + '/lab7_pkg/goals/' + filename):
                return self.root_dir + '/lab7_pkg/goals/' + filename
            else:
                print("File does not exist. Try again.")
    
    def get_state(self) -> bool:
        """
        Query user for program state (mapping / driving) to use during execution.
        
        Returns:
            True if the mapping state is active, otherwise False
        """
        
        while True:
            try:
                response = input('Which Mode ([M]apping, [D]riving): ')

                if response.find('M') == 0:
                    return True
                elif response.find('D') == 0:
                    # Acquire saved global occupancy grid
                    self.global_occ_grid = self.read_global_occ()
                    
                    # Render global occupancy grid
                    self.render_global_occ()
                    
                    return False
            except Exception as e:
                print(f"Exception occurred: [{type(e)}] {e}")
            
            print("Invalid choice. Try again.")
    
    def halt(self):
        drive_msg = AckermannDriveStamped()
        drive_msg.drive.speed = 0.0
        drive_msg.drive.steering_angle = 0.0
        
        self.drive_pub.publish(drive_msg)
        
        if self.mapping:
            self.save_global_occ()
    
    # ==============================================================================================
    # File Interface Functions
    # ==============================================================================================
    
    def read_goals(self) -> List[Vec2f]:
        """
        Acquire directional list of goal positions from file
        
        Returns:
            List of goal positions in order
        """
        
        goal_list : List[Vec2f] = []
        
        try:
            goalsCSV = open(self.goals_filename, "r")
            
            reader = csv.reader(goalsCSV, delimiter=',')
            
            for row in reader:
                try:
                    goal_list.append(Vec2f(float(row[0]), float(row[1])))
                except ValueError:
                    print("Failed to convert row data into Vec2f object.")
                    print(f"  Content: '{row}'")
            
            goalsCSV.close()
        except FileNotFoundError:
            print("Could not open goals file.")
        
        return goal_list
        
    
    def read_global_occ(self) -> Dict[Vec2, float]:
        """
        Acquire global occupancy grid from file
        
        Returns:
            Map from a cell's position to its occupancy status
        """
        
        global_occ_grid : Dict[Vec2, float] = {}
        
        try:
            globalCSV = open(self.global_occ_filename, "r")
            
            reader = csv.reader(globalCSV, delimiter=',')
            
            for row in reader:
                try:
                    global_occ_grid[Vec2(int(row[0]), int(row[1]))] = float(row[2])
                except ValueError:
                    print("Failed to convert row data into [Vec2, float] mapping.")
                    print(f"  Content: '{row}'")
                except Exception as e:
                    print(f"Exception occurred: [{type(e)}] {e}")
            
            globalCSV.close()
        except FileNotFoundError:
            print("Could not open global occupancy grid file.")
        
        return global_occ_grid
    
    def save_global_occ(self) -> None:
        """
        Save global occupancy grid to file
        
        Returns:
            None
        """
        
        try:
            globalCSV = open(self.global_occ_filename, "w")
            
            writer = csv.writer(globalCSV, delimiter=',')
            
            for position, occ_status in self.global_occ_grid.items():
                writer.writerow([position.x, position.y, occ_status])
            
            globalCSV.close()
        except FileNotFoundError:
            print("Could not open global occupancy grid file.")
    
    # ==============================================================================================
    # Subscription Callback Functions
    # ==============================================================================================
    
    def scan_callback(self, scan_msg : LaserScan) -> None:
        """
        Create the global occupancy grid while mapping mode is selected, otherwise create the local
        occupancy grid while driving mode is selected
        
        Args:
            scan_msg (LaserScan): incoming scan message from subscribed topic
        Returns:
            None
        """
        
        ranges = scan_msg.ranges
        
        if self.position != None:
            for i in range(vars.RANGE_SIZE):
                dist    = ranges[i] + 0.01  # extend point into occlusion for better grid cell accuracy
                car_dir = self.rotation
                theta   = car_dir + hp.idx_to_rad(i, vars.FOV, vars.RANGE_SIZE)
                
                x_las, y_las = 0.261 * np.cos(car_dir), 0.261 * np.sin(car_dir)
                x_offs, y_offs = x_las + dist * np.cos(theta), y_las + dist * np.sin(theta)
                
                occluded_cell = Vec2(
                    x = round((self.position.x + x_offs) / 0.05),
                    y = round((self.position.y + y_offs) / 0.05)
                )

                if self.mapping:
                    self.bubble(occluded_cell, self.global_occ_grid)
                else:
                    # reset local occupcancy grid
                    self.local_occ_grid.clear()
                    
                    if self.local_cell(occluded_cell):
                        self.bubble(occluded_cell, self.local_occ_grid)
    
    def pose_callback(self, pose_msg : PoseStamped) -> None:
        """
        Update position and rotation of car using inferred pose
        
        Args:
            pose_msg (PoseStamped): incoming pose message from subscribed topic
        Returns:
            None
        """
        
        p : Point = pose_msg.pose.position
        q : Quaternion = pose_msg.pose.orientation
        
        self.position = Vec2f(p.x, p.y)
        self.cell_pos = Vec2(round(p.x / 0.05), round(p.y / 0.05))
        self.rotation = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
    
    def odom_callback(self, odom_msg : Odometry) -> None:
        """
        Update position and rotation of car using simulated odometry
        
        Args:
            odom_msg (Odometry): incoming odometry message from subscribed topic
        Returns:
            None
        """
        
        p : Point = odom_msg.pose.pose.position
        q : Quaternion = odom_msg.pose.pose.orientation
        
        self.position = Vec2f(p.x, p.y)
        self.cell_pos = Vec2(round(p.x / 0.05), round(p.y / 0.05))
        self.rotation = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
    
    # ==============================================================================================
    # Visualization Functions
    # ==============================================================================================
    
    def render_global_occ(self) -> None:
        """
        Create and publish an OccupancyGrid message containing the global occupancy grid to the
        rviz2 client
        
        Returns:
            None
        """
        
        markers : MarkerArray = MarkerArray()
        
        j = 0
        
        for position, occ_status in self.global_occ_grid.items():
            # print(f"({position.x},{position.y}) @ ({position.x * self.cell_size},{position.y * self.cell_size}) -> {occ_status}")
            if occ_status == 1.0:
                marker : Marker = Marker()
                
                marker.header.frame_id = "map"
                marker.header.stamp = self.get_clock().now().to_msg()
                marker.ns = "ns_globalocc"
                
                marker.id = j
                marker.type = Marker.CUBE
                marker.action = Marker.ADD
                
                marker.pose.position.x = position.x * self.cell_size
                marker.pose.position.y = position.y * self.cell_size
                marker.pose.position.z = 1.0
                
                marker.pose.orientation.x = 0.0
                marker.pose.orientation.y = 0.0
                marker.pose.orientation.z = 0.0
                marker.pose.orientation.w = 1.0
                
                marker.scale.x = 0.04
                marker.scale.y = 0.04
                marker.scale.z = 0.04
                
                marker.color.r = 1.0
                marker.color.g = 0.0
                marker.color.b = 0.0
                marker.color.a = 0.8
                
                markers.markers.append(marker)
                
                j += 1
        
        self.global_occ_pub.publish(markers)
    
    def render_local_occ(self) -> None:
        """
        Create and publish an OccupancyGrid message containing the local occupancy grid to the
        rviz2 client
        
        Returns:
            None
        """
    
    def render_sample_grid(self) -> None:
        """
        Create and publish a MarkerArray message defining the local sample space around the car to
        the rviz2 client
        
        Returns:
            None
        """
    
    def render_path(self) -> None:
        """
        Create and publish a MarkerArray message defining the discovered path to the current goal to
        the rviz2 client
        
        Returns:
            None
        """
    
    def render_goals(self) -> None:
        """
        Create and publish a MarkerArray message defining the goals around the map to the rviz2
        client
        
        Returns:
            None
        """
    
    # ==============================================================================================
    # Occupancy Grid Functions
    # ==============================================================================================
    
    def bubble(self, position : Vec2, occ_grid : Dict[Vec2, float]) -> None:
        """
        Expand the occupation grid around the given position to account for the car's dimensions
        
        Args:
            position (Vec2): cell position in the occupancy grid to bubble around
            occ_grid (Dict[Vec2, float]): the occupancy grid
        Returns:
            None
        """
        
        for offs in self.bubble_offs:
            occ_grid[Vec2(position.x + offs.x, position.y + offs.y)] = 1.0
    
    def local_cell(self, position : Vec2) -> bool:
        """
        Determines if a specified cell is within the bounds of the local occupancy grid
        
        Args:
            position (Vec2): position of the cell to check
        Returns:
            True if the cell position is part of the local occupancy grid, False otherwise
        """
        
        p1 : Vec2  = Vec2(self.cell_pos.x, self.cell_pos.y)
        p2 : Vec2  = Vec2(self.curr_goal.x, self.curr_goal.y)
        
        theta : float = np.arctan2(p2.y - p1.y, p2.x - p1.x)
        
        cos = np.cos(theta)
        sin = np.sin(theta)
        x_diff = position.x - p1.x
        y_diff = position.y - p1.y
        
        transPoint : Vec2 = Vec2(
            x = round(x_diff * cos + y_diff * sin),
            y = round(y_diff * cos - x_diff * sin)
        )
        
        return (
            transPoint.x >= 0 and transPoint.x <= self.local_depth and
            abs(transPoint.y) <= self.local_width
        )

def main(args=None):
    rclpy.init(args=args)
    
    print("Dynamic Node Initialized")
    
    dynamic_node = Dynamic()
    
    atexit.register(dynamic_node.halt)
    
    rclpy.spin(dynamic_node)
    
    dynamic_node.destroy_node()
    
    rclpy.shutdown()

if __name__ == '__main__':
    main()
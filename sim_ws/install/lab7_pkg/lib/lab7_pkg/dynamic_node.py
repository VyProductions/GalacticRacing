#!/usr/bin/env python3

# ==================================================================================================
# Standard Imports
# ==================================================================================================

import csv
import numpy as np
import math
import atexit
import os
from scanf import scanf

# ==================================================================================================
# ROS Imports
# ==================================================================================================

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import PoseStamped, Pose, Quaternion, Point
from nav_msgs.msg import Odometry, OccupancyGrid
from ackermann_msgs.msg import AckermannDriveStamped
from visualization_msgs.msg import Marker, MarkerArray
from tf_transformations import euler_from_quaternion

# ==================================================================================================
# Utility Imports
# ==================================================================================================

import lab7_pkg.helper as hp
import lab7_pkg.variables as vars

# ==================================================================================================
# Miscellaneous Imports
# ==================================================================================================

from typing import *

# ==================================================================================================
# Vec2 Class
# ==================================================================================================

class Vec2:
    def __init__(
        self,
        x : int = 0,
        y : int = 0
    ):
        self.x = int(x)
        self.y = int(y)

    # Generated by ChatGPT for use as a key in a dictionary
    def __eq__(self, other):
        if isinstance(other, Vec2):
            return self.x == other.x and self.y == other.y
        return False

    def __hash__(self):
        return hash((self.x, self.y))

class Vec2f:
    def __init__(
        self,
        x : float = 0.0,
        y : float = 0.0
    ):
        self.x = float(x)
        self.y = float(y)

# ==================================================================================================
# Vertex Class
# ==================================================================================================

class Vertex:
    def __init__(
        self,
        position : Vec2 = Vec2(),
        parent = None,
        input_dir : float = 0.0,
        cost : float = 0.0
    ):
        self.position = position
        self.parent = parent
        self.input_dir = input_dir
        self.cost = cost

# ==================================================================================================
# Dynamic Node Class
# ==================================================================================================

class Dynamic(Node):
    def __init__(self):
        super().__init__('dynamic_node')
        
        # ==========================================================================================
        # Subscriber / Publisher Topics
        # ==========================================================================================
        
        # Car
        scan_topic  = '/scan'
        pose_topic  = '/pf/viz/inferred_pos'
        odom_topic  = '/ego_racecar/odom'
        drive_topic = '/drive'
        
        # Map
        global_occ_topic = '/global_occupancy'
        local_occ_topic  = '/local_occupancy'
        
        # Pathing
        sample_grid_topic = '/sample_grid'
        path_topic        = '/path_view'
        goals_topic       = '/goal_view'
        
        # ==========================================================================================
        # Subscribers / Publishers
        # ==========================================================================================
        
        # Car
        self.scan_sub  = self.create_subscription(LaserScan, scan_topic, self.scan_callback, 10)
        self.pose_sub  = self.create_subscription(PoseStamped, pose_topic, self.pose_callback, 10)
        self.odom_sub  = self.create_subscription(Odometry, odom_topic, self.odom_callback, 10)
        self.drive_pub = self.create_publisher(AckermannDriveStamped, drive_topic, 10)
        
        # Map
        self.global_occ_pub = self.create_publisher(OccupancyGrid, global_occ_topic, 10)
        self.local_occ_pub  = self.create_publisher(OccupancyGrid, local_occ_topic, 10)

        # Pathing
        self.sample_grid_pub = self.create_publisher(MarkerArray, sample_grid_topic, 10)
        self.path_pub        = self.create_publisher(MarkerArray, path_topic, 10)
        self.goals_pub       = self.create_publisher(MarkerArray, goals_topic, 10)
        
        # ==========================================================================================
        # Runtime Variables
        # ==========================================================================================
        
        # Car
        self.position : Vec2f = None  # Physical position of car on map
        self.cell_pos : Vec2  = None  # Cell position of car on map
        self.rotation : float = None  # Rotation relative to map frame (radians)
        
        # Map
        self.global_occ_grid : Dict[Vec2, float] = {}  # Static global occupancy grid
        self.free_space_grid : Dict[Vec2, float] = {}  # Static free space grid for track
        self.local_occ_grid  : Dict[Vec2, float] = {}  # Dynamic local occupancy grid
        self.map_config      : Dict[str, Any]    = {}  # Map configuration details
        
        # Pathing
        self.curr_goal : Vec2  = Vec2()        # Cell position for current goal
        self.known_free : Vec2 = Vec2(0, 100)  # Cell known to be in free space
        
        # ==========================================================================================
        # Runtime Constants
        # ==========================================================================================
        
        # Occupancy Grid
        self.cell_size   : float = 0.05
        self.local_width : int   = 40
        self.local_depth : int   = 40
        self.bubble_offs : List[Vec2] = [
            Vec2( 0,  0), Vec2( 0, -1), Vec2( 1,  0), Vec2(-1,  0), Vec2( 0,  1), Vec2( 1,  1),
            Vec2( 1, -1), Vec2(-1,  1), Vec2(-1, -1), Vec2( 0, -2), Vec2( 2,  0), Vec2(-2,  0),
            Vec2( 0,  2), Vec2( 2, -1), Vec2(-1,  2), Vec2(-1, -2), Vec2(-2,  1), Vec2(-2, -1),
            Vec2( 1, -2), Vec2( 1,  2), Vec2( 2,  1), Vec2( 2, -2), Vec2( 2,  2), Vec2(-2,  2),
            Vec2(-2, -2), Vec2( 0, -3), Vec2( 0,  3), Vec2( 3,  0), Vec2(-3,  0), Vec2(-1,  3),
            Vec2(-1, -3), Vec2( 3, -1), Vec2( 1, -3), Vec2( 3,  1), Vec2(-3,  1), Vec2( 1,  3),
            Vec2(-3, -1), Vec2( 3, -2), Vec2( 2,  3), Vec2(-3, -2), Vec2( 3,  2), Vec2( 2, -3),
            Vec2(-2,  3), Vec2(-2, -3), Vec2(-3,  2), Vec2( 0,  4), Vec2( 0, -4), Vec2(-4,  0),
            Vec2( 4,  0)
        ]
        
        # Environment Information
        self.root_dir : str = self.get_root_dir()  # Parent directory to package folders
        
        # File Information
        self.global_occ_filename : str = self.get_global_occ_filename()  # Global occupancy filename
        self.goals_filename      : str = self.get_goals_filename()       # Local occupancy filename
        self.map_filename        : str = self.get_map_filename()         # Map information filename
        
        # Status
        self.mapping : bool = self.get_state()  # Whether the program is in mapping or driving mode
        
        # Pathing
        self.goal_list : List[Vec2] = self.read_goals()  # Ordered list of goal cells around the map
    
    # ==============================================================================================
    # Setup / Teardown Functions
    # ==============================================================================================
    
    def get_root_dir(self) -> str:
        """
        Query user for full path of parent folder to package folders
        
        Returns:
            Path string for root directory
        """
        
        while True:
            # path : str = input("Enter package root directory: ")
            path : str = '/home/vy/GalacticRacing/sim_ws/src'
            
            if os.path.exists(path):
                return path
            else:
                print("Invalid path. Try again.")
    
    def get_global_occ_filename(self) -> str:
        """
        Query user for global occupancy grid filename
        
        Returns:
            Full path to global occupancy grid file
        """
        
        while True:
            filename : str = input("Enter global occupancy filename: ")
            # filename : str = 'AEB_flexito.csv'
            
            if os.path.exists(self.root_dir + '/lab7_pkg/occ_grids/' + filename):
                return self.root_dir + '/lab7_pkg/occ_grids/' + filename
            else:
                print("File does not exist. Try again.")
    
    def get_goals_filename(self) -> str:
        """
        Query user for goal markers filename
        
        Returns:
            Full path to goal markers file
        """
        
        while True:
            filename : str = input("Enter goal marker filename: ")
            # filename : str = 'AEB_flexito.csv'
            
            if os.path.exists(self.root_dir + '/lab7_pkg/goals/' + filename):
                return self.root_dir + '/lab7_pkg/goals/' + filename
            else:
                print("File does not exist. Try again.")
    
    def get_map_filename(self) -> str:
        """
        Query user for map information filename
        
        Returns:
            Full path to map file (no extension)
        """
        
        while True:
            filename : str = input("Enter map filename (no extension): ")
            # filename : str = 'AEB_flexito'
            
            if (
                os.path.exists(self.root_dir + '/particle_filter/maps/' + filename + '.yaml') and
                (
                    os.path.exists(self.root_dir + '/particle_filter/maps/' + filename + '.png') or
                    os.path.exists(self.root_dir + '/particle_filter/maps/' + filename + '.pgm')
                )
            ):
                return self.root_dir + '/particle_filter/maps/' + filename
            else:
                print("Map image and config file do not exist. Try again.")
    
    def get_map_config(self) -> None:
        """
        Read configuration file to acquire dimensions and origin of map
        
        Returns:
            None
        """

        try:
            lines : List[str] = []
            
            for i in open(self.map_filename + '.yaml', "r"):
                lines.append(i)
            
            self.map_config["image"] = scanf("image: %s\n", lines[0])[0]
            self.map_config["mode"] = scanf("mode: %s\n", lines[1])[0]
            self.map_config["resolution"] = scanf("resolution: %f\n", lines[2])[0]
            originPos = scanf("origin: [%f, %f, %f]\n", lines[3])
            self.map_config["origin"] = Vec2f(x=originPos[0], y=originPos[1])
            self.map_config["negate"] = scanf("negate: %d\n", lines[4])[0]
            self.map_config["occupied_thresh"] = scanf("occupied_thresh: %f\n", lines[5])[0]
            self.map_config["free_thresh"] = scanf("free_thresh: %f", lines[6])[0]
            
            image_dims : str = ""
            
            with open(self.root_dir + '/particle_filter/maps/' + self.map_config["image"], "rb") as f:
                first_line = f.readline().decode()
                
                if first_line != "P5\n":
                    print("Not a P5 image file.")
                else:
                    # acquire image dimensions
                    image_dims = f.readline().decode()
            
            self.map_config["width"], self.map_config["height"] = scanf("%d %d\n", image_dims)
        except FileNotFoundError:
            print("Could not open map config file. Try again.")
        except Exception as e:
            print(f"Exception occurred: [{type(e)}] {e}")
    
    def get_state(self) -> bool:
        """
        Query user for program state (mapping / driving) to use during execution.
        
        Returns:
            True if the mapping state is active, otherwise False
        """
        
        while True:
            try:
                response = input('Which Mode ([M]apping, [D]riving): ')

                if response.find('M') == 0:
                    # Acquire map config information
                    self.get_map_config()
                    
                    return True
                elif response.find('D') == 0:
                    # Acquire saved global occupancy grid
                    self.global_occ_grid = self.read_global_occ()
                    
                    # Acquire map config information
                    self.get_map_config()
                    
                    # Flood-fill from where car is (assumed to be on track) to acquire free space
                    self.flood_fill()
                    
                    # Render global occupancy grid
                    self.render_global_occ()
                    
                    return False
            except Exception as e:
                print(f"Exception occurred: [{type(e)}] {e}")
            
            print("Invalid choice. Try again.")
    
    def halt(self):
        drive_msg = AckermannDriveStamped()
        drive_msg.drive.speed = 0.0
        drive_msg.drive.steering_angle = 0.0
        
        self.drive_pub.publish(drive_msg)
        
        if self.mapping:
            self.save_global_occ()
    
    # ==============================================================================================
    # File Interface Functions
    # ==============================================================================================
    
    def read_goals(self) -> List[Vec2f]:
        """
        Acquire directional list of goal positions from file
        
        Returns:
            List of goal positions in order
        """
        
        goal_list : List[Vec2f] = []
        
        try:
            goalsCSV = open(self.goals_filename, "r")
            
            reader = csv.reader(goalsCSV, delimiter=',')
            
            for row in reader:
                try:
                    goal_list.append(Vec2f(float(row[0]), float(row[1])))
                except ValueError:
                    print("Failed to convert row data into Vec2f object.")
                    print(f"  Content: '{row}'")
            
            goalsCSV.close()
        except FileNotFoundError:
            print("Could not open goals file.")
        
        return goal_list
        
    
    def read_global_occ(self) -> Dict[Vec2, float]:
        """
        Acquire global occupancy grid from file
        
        Returns:
            Map from a cell's position to its occupancy status
        """
        
        global_occ_grid : Dict[Vec2, float] = {}
        
        try:
            globalCSV = open(self.global_occ_filename, "r")
            
            reader = csv.reader(globalCSV, delimiter=',')
            
            for row in reader:
                try:
                    global_occ_grid[Vec2(int(row[0]), int(row[1]))] = float(row[2])
                except ValueError:
                    print("Failed to convert row data into [Vec2, float] mapping.")
                    print(f"  Content: '{row}'")
                except Exception as e:
                    print(f"Exception occurred: [{type(e)}] {e}")
            
            globalCSV.close()
        except FileNotFoundError:
            print("Could not open global occupancy grid file.")
        
        return global_occ_grid
    
    def save_global_occ(self) -> None:
        """
        Save global occupancy grid to file
        
        Returns:
            None
        """
        
        try:
            globalCSV = open(self.global_occ_filename, "w")
            
            writer = csv.writer(globalCSV, delimiter=',')
            
            for position, occ_status in self.global_occ_grid.items():
                writer.writerow([position.x, position.y, occ_status])
            
            globalCSV.close()
        except FileNotFoundError:
            print("Could not open global occupancy grid file.")
    
    # ==============================================================================================
    # Subscription Callback Functions
    # ==============================================================================================
    
    def scan_callback(self, scan_msg : LaserScan) -> None:
        """
        Create the global occupancy grid while mapping mode is selected, otherwise create the local
        occupancy grid while driving mode is selected
        
        Args:
            scan_msg (LaserScan): incoming scan message from subscribed topic
        Returns:
            None
        """
        
        # reset local occupcancy grid in driving mode
        if not self.mapping:
            self.local_occ_grid.clear()
        
        ranges = scan_msg.ranges
        
        if self.position != None:
            for i in range(vars.RANGE_SIZE):
                dist    = ranges[i] + 0.01  # extend point into occlusion for better grid cell accuracy
                car_dir = self.rotation
                theta   = car_dir + hp.idx_to_rad(i, vars.FOV, vars.RANGE_SIZE)
                
                x_las, y_las = 0.261 * np.cos(car_dir), 0.261 * np.sin(car_dir)
                x_offs, y_offs = x_las + dist * np.cos(theta), y_las + dist * np.sin(theta)
                
                occluded_cell = Vec2(
                    x = round((self.position.x + x_offs) / 0.05),
                    y = round((self.position.y + y_offs) / 0.05)
                )
                
                if self.mapping:
                    self.bubble(occluded_cell, self.global_occ_grid)
                else:
                    if self.local_cell(occluded_cell):
                        self.bubble(occluded_cell, self.local_occ_grid)
        
        self.render_local_occ()
    
    def pose_callback(self, pose_msg : PoseStamped) -> None:
        """
        Update position and rotation of car using inferred pose
        
        Args:
            pose_msg (PoseStamped): incoming pose message from subscribed topic
        Returns:
            None
        """
        
        p : Point = pose_msg.pose.position
        q : Quaternion = pose_msg.pose.orientation
        
        self.position = Vec2f(p.x, p.y)
        self.cell_pos = Vec2(round(p.x / 0.05), round(p.y / 0.05))
        self.rotation = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
    
    def odom_callback(self, odom_msg : Odometry) -> None:
        """
        Update position and rotation of car using simulated odometry
        
        Args:
            odom_msg (Odometry): incoming odometry message from subscribed topic
        Returns:
            None
        """
        
        p : Point = odom_msg.pose.pose.position
        q : Quaternion = odom_msg.pose.pose.orientation
        
        self.position = Vec2f(p.x, p.y)
        self.cell_pos = Vec2(round(p.x / 0.05), round(p.y / 0.05))
        self.rotation = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
    
    # ==============================================================================================
    # Visualization Functions
    # ==============================================================================================
    
    def float_to_cell_coordinate(self, x, y):
        # Calculate scaled coordinates in terms of cell units
        x_scaled = x / self.cell_size
        y_scaled = y / self.cell_size

        # Calculate row index
        row = self.map_config["height"] - 1 - int(y_scaled * (self.map_config["height"] - 1))

        # Calculate column index
        col = int(x_scaled * (self.map_config["width"] - 1))

        return row, col
    
    def render_global_occ(self) -> None:
        """
        Create and publish an OccupancyGrid message containing the global occupancy grid to the
        rviz2 client
        
        Returns:
            None
        """
        
        global_occ : OccupancyGrid = OccupancyGrid()
        
        global_occ.header.frame_id = "map"
        global_occ.header.stamp = self.get_clock().now().to_msg()
        
        global_occ.info.map_load_time = self.get_clock().now().to_msg()
        global_occ.info.resolution = self.map_config["resolution"]
        global_occ.info.width = self.map_config["width"]
        global_occ.info.height = self.map_config["height"]
        global_occ.info.origin = Pose(
            position=Point(
                x=self.map_config["origin"].x,
                y=self.map_config["origin"].y,
                z=0.0
            ),
            orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)
        )
        
        num_cells = self.map_config["height"] * self.map_config["width"]
        
        global_occ.data = [0] * num_cells
        
        origin_pt : Vec2f = self.map_config["origin"]
        
        C, R = self.map_config["width"], self.map_config["height"]
        
        for r in range(R):
            for c in range(C):
                pos : Vec2 = Vec2(
                    x=c + round((origin_pt.x + self.cell_size / 2) / self.cell_size),
                    y=round((origin_pt.y + self.cell_size / 2) / self.cell_size) + r
                )
                
                if pos in self.global_occ_grid:
                    global_occ.data[r * C + c] = 100
                elif pos in self.free_space_grid:
                    global_occ.data[r * C + c] = 0
                else:
                    global_occ.data[r * C + c] = -1
        
        self.global_occ_pub.publish(global_occ)
    
    def render_local_occ(self) -> None:
        """
        Create and publish an OccupancyGrid message containing the local occupancy grid to the
        rviz2 client
        
        Returns:
            None
        """
        
        local_occ : OccupancyGrid = OccupancyGrid()
        
        local_occ.header.frame_id = "map"
        local_occ.header.stamp = self.get_clock().now().to_msg()
        
        local_occ.info.map_load_time = self.get_clock().now().to_msg()
        local_occ.info.resolution = self.map_config["resolution"]
        local_occ.info.width = self.map_config["width"]
        local_occ.info.height = self.map_config["height"]
        local_occ.info.origin = Pose(
            position=Point(
                x=self.map_config["origin"].x,
                y=self.map_config["origin"].y,
                z=0.0
            ),
            orientation=Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)
        )
        
        num_cells = self.map_config["height"] * self.map_config["width"]
        
        local_occ.data = [0] * num_cells
        
        origin_pt : Vec2f = self.map_config["origin"]
        
        C, R = self.map_config["width"], self.map_config["height"]
        
        for r in range(R):
            for c in range(C):
                pos : Vec2 = Vec2(
                    x=c + round((origin_pt.x + self.cell_size / 2) / self.cell_size),
                    y=round((origin_pt.y + self.cell_size / 2) / self.cell_size) + r
                )
                
                if pos in self.local_occ_grid:
                    local_occ.data[r * C + c] = 100
                elif pos in self.free_space_grid:
                    local_occ.data[r * C + c] = 0
                else:
                    local_occ.data[r * C + c] = -1
        
        self.local_occ_pub.publish(local_occ)
    
    def render_sample_grid(self) -> None:
        """
        Create and publish a MarkerArray message defining the local sample space around the car to
        the rviz2 client
        
        Returns:
            None
        """
    
    def render_path(self) -> None:
        """
        Create and publish a MarkerArray message defining the discovered path to the current goal to
        the rviz2 client
        
        Returns:
            None
        """
    
    def render_goals(self) -> None:
        """
        Create and publish a MarkerArray message defining the goals around the map to the rviz2
        client
        
        Returns:
            None
        """
    
    # ==============================================================================================
    # Occupancy Grid Functions
    # ==============================================================================================
    
    def bubble(self, position : Vec2, occ_grid : Dict[Vec2, float]) -> None:
        """
        Expand the occupation grid around the given position to account for the car's dimensions
        
        Args:
            position (Vec2): cell position in the occupancy grid to bubble around
            occ_grid (Dict[Vec2, float]): the occupancy grid
        Returns:
            None
        """
        
        for offs in self.bubble_offs:
            occ_grid[Vec2(position.x + offs.x, position.y + offs.y)] = 1.0
    
    def local_cell(self, position : Vec2) -> bool:
        """
        Determines if a specified cell is within the bounds of the local occupancy grid
        
        Args:
            position (Vec2): position of the cell to check
        Returns:
            True if the cell position is part of the local occupancy grid, False otherwise
        """
        
        p1 : Vec2  = Vec2(self.cell_pos.x, self.cell_pos.y)
        
        cos = np.cos(self.rotation)
        sin = np.sin(self.rotation)
        x_diff = position.x - p1.x
        y_diff = position.y - p1.y
        
        transPoint : Vec2 = Vec2(
            x = round(x_diff * cos + y_diff * sin),
            y = round(y_diff * cos - x_diff * sin)
        )
        
        return (
            transPoint.x >= 0 and transPoint.x <= self.local_depth and
            abs(transPoint.y) <= self.local_width
        )
    
    def flood_fill(self):
        free_cells : Dict[Vec2, bool] = {
            self.known_free: True
        }
        
        proc_cells : Dict[Vec2, bool] = {}
        
        offs : List[Vec2] = [
            Vec2(-1, -1), Vec2( 0, -1), Vec2( 1, -1),
            Vec2(-1,  0),               Vec2( 1,  0),
            Vec2(-1,  1), Vec2( 0,  1), Vec2( 1,  1)
        ]
        
        while len(free_cells) > 0:
            curr_cell, _ = free_cells.popitem()
            
            proc_cells[curr_cell] = True
            
            self.free_space_grid[curr_cell] = 0.0
            
            for v in offs:
                new_pos : Vec2 = Vec2(x=curr_cell.x + v.x, y=curr_cell.y + v.y)
                
                if new_pos not in self.global_occ_grid and new_pos not in proc_cells:
                    free_cells[new_pos] = True

def main(args=None):
    rclpy.init(args=args)
    
    print("Dynamic Node Initialized")
    
    dynamic_node = Dynamic()
    
    atexit.register(dynamic_node.halt)
    
    rclpy.spin(dynamic_node)
    
    dynamic_node.destroy_node()
    
    rclpy.shutdown()

if __name__ == '__main__':
    main()